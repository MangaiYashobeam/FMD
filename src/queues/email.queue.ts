import { Queue, Worker, Job } from 'bullmq';
import { emailService, EmailOptions, EmailTemplate } from '@/services/email.service';
import { logger } from '@/utils/logger';
import Redis from 'ioredis';

/**
 * Email Queue System
 * Handles reliable email delivery with retry logic
 */

interface EmailJob {
  type: 'direct' | 'template';
  options?: EmailOptions;
  template?: EmailTemplate;
  to?: string | string[];
  variables?: Record<string, any>;
}

const connection = new Redis({
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD,
  maxRetriesPerRequest: null,
});

// Create email queue
export const emailQueue = new Queue<EmailJob>('email', {
  connection,
  defaultJobOptions: {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 5000, // Start with 5s, then 10s, then 20s
    },
    removeOnComplete: {
      age: 24 * 3600, // Keep completed jobs for 24 hours
      count: 1000,
    },
    removeOnFail: {
      age: 7 * 24 * 3600, // Keep failed jobs for 7 days
    },
  },
});

// Worker to process email jobs
export const emailWorker = new Worker<EmailJob>(
  'email',
  async (job: Job<EmailJob>) => {
    const { type, options, template, to, variables } = job.data;

    logger.info(`Processing email job ${job.id} (type: ${type})`);

    try {
      let result: boolean;

      if (type === 'direct' && options) {
        result = await emailService.sendEmail(options);
      } else if (type === 'template' && template && to) {
        result = await emailService.sendTemplateEmail(template, to, variables);
      } else {
        throw new Error('Invalid email job data');
      }

      if (!result) {
        throw new Error('Email sending failed');
      }

      logger.info(`âœ… Email job ${job.id} completed successfully`);
      return { success: true, jobId: job.id };
    } catch (error) {
      logger.error(`âŒ Email job ${job.id} failed:`, error);
      throw error;
    }
  },
  {
    connection,
    concurrency: 5, // Process 5 emails simultaneously
  }
);

// Queue event listeners
emailQueue.on('error', (error) => {
  logger.error('Email queue error:', error);
});

emailWorker.on('failed', (job, error) => {
  if (job) {
    logger.error(`Email job ${job.id} failed after ${job.attemptsMade} attempts:`, error);
  }
});

emailWorker.on('completed', (job) => {
  logger.info(`Email job ${job.id} completed`);
});

/**
 * Queue email for sending
 */
export async function queueEmail(options: EmailOptions, priority?: number) {
  await emailQueue.add(
    'send-email',
    {
      type: 'direct',
      options,
    },
    {
      priority,
    }
  );
}

/**
 * Queue template email
 */
export async function queueTemplateEmail(
  template: EmailTemplate,
  to: string | string[],
  variables?: Record<string, any>,
  priority?: number
) {
  await emailQueue.add(
    'send-template-email',
    {
      type: 'template',
      template,
      to,
      variables,
    },
    {
      priority,
    }
  );
}

/**
 * Welcome email helper
 */
export async function queueWelcomeEmail(
  userEmail: string,
  userName: string,
  tempPassword?: string
) {
  await emailQueue.add('welcome-email', {
    type: 'direct',
    options: {
      to: userEmail,
      subject: 'Welcome to FaceMyDealer! ðŸš—',
      html: '', // Will be generated by service
    },
  });

  // Use service directly to leverage built-in template
  await emailService.sendWelcomeEmail(userEmail, userName, tempPassword);
}

/**
 * Password reset helper
 */
export async function queuePasswordResetEmail(
  userEmail: string,
  resetToken: string,
  userName: string
) {
  await emailService.sendPasswordResetEmail(userEmail, resetToken, userName);
}

/**
 * Sync completion helper
 */
export async function queueSyncCompletionEmail(
  userEmail: string,
  accountName: string,
  stats: { imported: number; updated: number; failed: number }
) {
  await emailService.sendSyncCompletionEmail(userEmail, accountName, stats);
}

/**
 * Payment receipt helper
 */
export async function queuePaymentReceiptEmail(
  userEmail: string,
  amount: number,
  invoiceUrl: string,
  accountName: string
) {
  await emailService.sendPaymentReceiptEmail(userEmail, amount, invoiceUrl, accountName);
}

/**
 * Payment failure helper
 */
export async function queuePaymentFailedEmail(
  userEmail: string,
  amount: number,
  reason: string
) {
  await emailService.sendPaymentFailedEmail(userEmail, amount, reason);
}

/**
 * Daily digest helper
 */
export async function queueDailyDigest(
  userEmail: string,
  stats: {
    newPosts: number;
    totalViews: number;
    messages: number;
    syncStatus: string;
  }
) {
  await emailService.sendDailyDigest(userEmail, stats);
}

/**
 * Shutdown email queue gracefully
 */
export async function shutdownEmailQueue() {
  logger.info('Shutting down email queue...');
  await emailWorker.close();
  await emailQueue.close();
  await connection.quit();
  logger.info('Email queue shut down complete');
}
