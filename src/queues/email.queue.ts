import { Queue, Worker, Job } from 'bullmq';
import { emailService, EmailOptions, EmailTemplate } from '@/services/email.service';
import { logger } from '@/utils/logger';
import { getRedisConnection } from '@/config/redis';

/**
 * Email Queue System
 * Handles reliable email delivery with retry logic
 */

interface EmailJob {
  type: 'direct' | 'template';
  options?: EmailOptions;
  template?: EmailTemplate;
  to?: string | string[];
  variables?: Record<string, any>;
}

const connection = getRedisConnection();

// Create email queue only if Redis is available
export const emailQueue = connection ? new Queue<EmailJob>('email', {
  connection,
  defaultJobOptions: {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 5000, // Start with 5s, then 10s, then 20s
    },
    removeOnComplete: {
      age: 24 * 3600, // Keep completed jobs for 24 hours
      count: 1000,
    },
    removeOnFail: {
      age: 7 * 24 * 3600, // Keep failed jobs for 7 days
    },
  },
}) : null;

// Worker to process email jobs (only if Redis is available)
export const emailWorker = connection ? new Worker<EmailJob>(
  'email',
  async (job: Job<EmailJob>) => {
    const { type, options, template, to, variables } = job.data;

    logger.info(`Processing email job ${job.id} (type: ${type})`);

    try {
      let result: boolean;

      if (type === 'direct' && options) {
        result = await emailService.sendEmail(options);
      } else if (type === 'template' && template && to) {
        result = await emailService.sendTemplateEmail(template, to, variables);
      } else {
        throw new Error('Invalid email job data');
      }

      if (!result) {
        throw new Error('Email sending failed');
      }

      logger.info(`âœ… Email job ${job.id} completed successfully`);
      return { success: true, jobId: job.id };
    } catch (error) {
      logger.error(`âŒ Email job ${job.id} failed:`, error);
      throw error;
    }
  },
  {
    connection: connection!,
    concurrency: 5, // Process 5 emails simultaneously
  }
) : null;

// Queue event listeners (only if queue exists)
if (emailQueue) {
  emailQueue.on('error', (error) => {
    logger.error('Email queue error:', error);
  });
}

if (emailWorker) {
  emailWorker.on('failed', (job, error) => {
    if (job) {
      logger.error(`Email job ${job.id} failed after ${job.attemptsMade} attempts:`, error);
    }
  });

  emailWorker.on('completed', (job) => {
    logger.info(`Email job ${job.id} completed`);
  });
}

/**
 * Queue email for sending
 */
export async function queueEmail(options: EmailOptions, priority?: number): Promise<boolean | void> {
  if (!emailQueue) {
    logger.warn('Email queue not available, sending email directly...');
    return await emailService.sendEmail(options);
  }
  
  await emailQueue.add(
    'send-email',
    {
      type: 'direct',
      options,
    },
    {
      priority,
    }
  );
  return true;
}

/**
 * Queue template email
 */
export async function queueTemplateEmail(
  template: EmailTemplate,
  to: string | string[],
  variables?: Record<string, any>,
  priority?: number
): Promise<boolean | void> {
  if (!emailQueue) {
    logger.warn('Email queue not available, sending template email directly...');
    return await emailService.sendTemplateEmail(template, to, variables);
  }
  
  await emailQueue.add(
    'send-template-email',
    {
      type: 'template',
      template,
      to,
      variables,
    },
    {
      priority,
    }
  );
  return true;
}

/**
 * Welcome email helper
 */
export async function queueWelcomeEmail(
  userEmail: string,
  userName: string,
  tempPassword?: string
): Promise<boolean | void> {
  if (!emailQueue) {
    logger.warn('Email queue not available, sending welcome email directly...');
    return await emailService.sendWelcomeEmail(userEmail, userName, tempPassword);
  }
  
  await emailQueue.add('welcome-email', {
    type: 'direct',
    options: {
      to: userEmail,
      subject: 'Welcome to Dealers Face! ðŸš—',
      html: '', // Will be generated by service
    },
  });
  return true;
}

/**
 * Password reset helper
 */
export async function queuePasswordResetEmail(
  userEmail: string,
  resetToken: string,
  userName: string
) {
  await emailService.sendPasswordResetEmail(userEmail, resetToken, userName);
}

/**
 * Sync completion helper
 */
export async function queueSyncCompletionEmail(
  userEmail: string,
  accountName: string,
  stats: { imported: number; updated: number; failed: number }
) {
  await emailService.sendSyncCompletionEmail(userEmail, accountName, stats);
}

/**
 * Payment receipt helper
 */
export async function queuePaymentReceiptEmail(
  userEmail: string,
  amount: number,
  invoiceUrl: string,
  accountName: string
) {
  await emailService.sendPaymentReceiptEmail(userEmail, amount, invoiceUrl, accountName);
}

/**
 * Payment failure helper
 */
export async function queuePaymentFailedEmail(
  userEmail: string,
  amount: number,
  reason: string
) {
  await emailService.sendPaymentFailedEmail(userEmail, amount, reason);
}

/**
 * Daily digest helper
 */
export async function queueDailyDigest(
  userEmail: string,
  stats: {
    newPosts: number;
    totalViews: number;
    messages: number;
    syncStatus: string;
  }
) {
  await emailService.sendDailyDigest(userEmail, stats);
}

/**
 * Shutdown email queue gracefully
 */
export async function shutdownEmailQueue() {
  if (!emailQueue || !emailWorker || !connection) {
    logger.info('Email queue not initialized, nothing to shutdown');
    return;
  }
  
  logger.info('Shutting down email queue...');
  try {
    await emailWorker.close();
    await emailQueue.close();
    await connection.quit();
    logger.info('Email queue shut down complete');
  } catch (error) {
    logger.error('Error shutting down email queue:', error);
  }
}
